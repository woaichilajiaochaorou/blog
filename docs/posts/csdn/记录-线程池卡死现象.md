---
title: "【记录】线程池卡死现象"
date: 2024-11-14
tags:
  - CSDN迁移
---

# 【记录】线程池卡死现象

在使用线程池时，错误的将completableFuture当成一种银弹，导致线程池卡死。  
有如下伪代码(去敏处理)：
    
    
    public List<?> funA(P params) {
    			
                // 异步获取数据
                
                List&lt;CompletableFuture&lt;Void&gt;> futures = sublist.parallelStream().map(data -> CompletableFuture.runAsync(() -> {
                     item = funB(params);
                }, executorService)).collect(Collectors.toList());
    		 CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
    }
    
    
    
    public List<?> funB(P params) {
                // 异步获取数据
                CompletableFuture&lt;List&lt;?&gt;> dataFuture = CompletableFuture.supplyAsync(() -> service.list(params), executor);
                
                List<?> data = dataFuture.join();
                return data;
    
    }
    

>   1. 在funA中异步调用funB，由于大量的执行funA耗尽线程池中所有线程
>   2. 直到funB执行任务时发现无线程可用（线程此时被funA持有），于是funB中的任务被放入阻塞队列。
>   3. funB在等待任务执行完成（永远无法执行），funA在等待funB完成，最终导致卡死。
> 

  * 解决办法
  * 1.子任务全部异步处理，在主线程同步。
  * 2.父子任务采用不同的线程池。
